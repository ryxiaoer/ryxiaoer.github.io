<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>muduo源码剖析 &amp; Linux多线程服务器端编程&lt;学习笔记 一&gt; | xiaoer's blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.1.0"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script type="text/javascript" src="https://news.qq.com/newsweather/showWeather.js"></script><script src="//msite.baidu.com/sdk/c.js?appid=1603347506741536"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 5.2.0"></head><body><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.3},"mathjax":true});</script></body><div class="search-total"><div class="search-quanbu"></div><div class="showSerch"></div></div><div class="header-02" id="header-02"><div class="header-02-1"><div class="nav2" id="nav1"><div class="header-02-2"><span class="logo-line-before"><i></i></span><a href="/.">xiaoer's blogs</a><span class="logo-line-before"><i></i></span></div><div class="header-02-3"><a class="current" href="/."><i class="fa fa-home2"> 首页</i></a><a href="/archives/"><i class="fa fa-archive2"> 时间轴</i></a><a href="/music/"><i class="fa fa-user2"> 音乐</i></a><a href="/tool/"><i class="fa fa-user2"> 工具</i></a><a href="/comment/"><i class="fa fa-rss2"> 留言</i></a></div><div class="header-03"><div class="header-02-5" onclick="showBars()"> <a  href="#"><i class="fa fa-bars" aria-hidden="true"></i></a></div><div class="header-02-4"> <a onclick="showSerch()" href="#"><i class="fa fa-search" aria-hidden="true"></i></a></div><div class="header-02-6"> <a  href="/."><i class="fa fa-home" aria-hidden="true"></i></a></div></div></div></div></div><div class="header-04" id="header-04" style="display: none;"> <div class="nav2"><a class="current" href="/."><i class="fa fa-home2"> homem</i></a><a href="/archives/"><i class="fa fa-archive2"> 时间轴</i></a><a href="/music/"><i class="fa fa-user2"> 音乐</i></a><a href="/tool/"><i class="fa fa-user2"> 工具</i></a><a href="/comment/"><i class="fa fa-rss2"> 留言</i></a><a href="/about/"><i class="fa fa-rss2"> 关于博主</i></a><a href="/site/"><i class="fa fa-rss2"> 关于本站</i></a><a href="/href/"><i class="fa fa-rss2"> 友情链接</i></a></div></div><div class="body_container"><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4" style="width: 100%;"><div class="content_container"><div class="post-02"></div><div class="post"><h1 class="post-title"><a href="/">muduo源码剖析 &amp; Linux多线程服务器端编程&lt;学习笔记 一&gt;</a></h1><div class="post-meta"><a href="https://ziyuan.baidu.com/xzh/commit/method?appid=1603347506741536" target="_Blank">10-17</a><span> | </span><span class="category"><a href="/categories/Code/">Code</a></span><span class="leancloud_visitors" id="/2020/10/17/blog-7.html" data-flag-title="文章阅读量统计">&nbsp;| <i class="fa fa-eye" aria-hidden="true"></i>&nbsp;<span class="leancloud-visitors-count"></span><span> 阅读</span></span></div><div style="float:right;margin:15px 0 0;"><span> <i class="fa fa-thumb-tack"></i> 置顶&nbsp;</span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">线程安全的对象生命期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">线程安全的定义
</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">如何保证？
</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%90%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">多线程中对象的析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">2.4.</span> <span class="toc-text">对象与指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">C++中的内存问题</span></a></li></ol></li></ol></div></div><br><br><div class="post-content"><p>muduo是在之前地平线一个大佬推荐的，并且推荐了配套书籍，真的非常感谢非常感谢他orz。对我来说真的有很大帮助,这篇博客本质是我的学习笔记，所以会不断更新。<br></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>muduo是陈硕大神开发的C++ TCP网络编程库，配合他自己的《Linux多线程服务器端编程》对于练习C++和网络编程来说都是很棒的教材。其源码在GitHub上可以直接下载，指路：<a target="_blank" rel="noopener" href="https://github.com/chenshuo/muduo">chenshuo</a>.</p>
<h2 id="线程安全的对象生命期管理"><a href="#线程安全的对象生命期管理" class="headerlink" title="线程安全的对象生命期管理"></a>线程安全的对象生命期管理</h2><p>线程安全可以通过mutex来保护，但mutex不能保护对象的生与死，当一个对象被多个线程同时看到，那么对象的销毁时机就会变得模糊不清，可能出现多种竞争条件(race condition)，这是C++多线程编程存在的基本问题，可以通过shared_ptr和weak_ptr解决。</p>
<h3 id="线程安全的定义"><a href="#线程安全的定义" class="headerlink" title="线程安全的定义"></a>线程安全的定义<br></h3><blockquote>
<p>多个线程同时访问时，其表现出正确的行为；<br><br>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织（interleaving）；<br><br>调用端代码无需额外的同步或其它操作<br></p>
</blockquote>
<p>  显然，STL库中的大多数class都是不安全的，因为他们通常要在加锁的情况下才能支持多线程访问。</p>
<h3 id="如何保证？"><a href="#如何保证？" class="headerlink" title="如何保证？"></a>如何保证？<br></h3><blockquote>
<p>利用shared_ptr和weak_ptr避免对象析构时存在的竞争条件(race conditon).<br><br>当一个对象被多个线程同时看到，那么对象的销毁时机就会变得模糊不清，可能出现多种竞争条件(race condition);<br><br>用RAII(Resource Acquire Is Initialization, 资源申请即初始化)封装互斥量的创建和销毁， MutexLock封装临界区(critical section), 资源管理类。<br><br>MutexLockGuard封装临界区的进入和退出，即加锁和解锁，MutexLockGuard一般是个栈上对象，它的作用域刚好等于临界区域。<br><br>不可拷贝类.<br></p>
<ul>
<li>把copy构造函数和复制操作符声明为私有函数并不声明。</li>
<li>在C++11中使用delete关键字，事实上muduo采用了这种方式：</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    noncopyable(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">    ~noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象构造要实现线程安全唯一的要求是在构造期间不要泄露this指针，即：</p>
<ul>
<li>不要在构造函数中注册任何回调函数<br></li>
<li>不要在构造函数中把this指针传给跨线程对象<br></li>
</ul>
</blockquote>
<h3 id="多线程中对象的析构"><a href="#多线程中对象的析构" class="headerlink" title="多线程中对象的析构"></a>多线程中对象的析构</h3><p>由于竞态条件的存在，多线程下对象的析构是很复杂的。对于一般成员函数而言，做到线程安全的办法是让他们依次执行，而不是并发执行（读写共享），也就是说要让每个成员函数的临界区不重叠，但是<strong>成员函数用来保护临界区的互斥锁必须是有效的，而析构函数破坏了这一条件</strong>，所以，在析构函数中直接调用互斥器进行多线程访问是不可取的，<br>没有达到线程安全的效果。所以说，作为数据成员的mutex不能保护析构， 因为成员的生命周期最多与对象一样长，而析构动作可以发生在对象死亡之后.</p>
<ul>
<li>析构函数本身不需要保护，因为只有别的线程都访问不到这个对象时，析构才是安全的</li>
</ul>
<p>此外，外如果要同时读写一个 class 的两个对象，有潜在的<em>死锁</em>可能。比方说有swap() 这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Counter&amp; a, Counter&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MutexLockGuard <span class="title">aLock</span><span class="params">(a.mutex_)</span></span>; <span class="comment">// potential dead lock</span></span><br><span class="line"><span class="function">MutexLockGuard <span class="title">bLock</span><span class="params">(b.mutex_)</span></span>;</span><br><span class="line"><span class="keyword">int64_t</span> value = a.value_;</span><br><span class="line">a.value_ = b.value_;</span><br><span class="line">b.value_ = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果线程 A 执行 swap(a, b); 而同时线程 B 执行 swap(b, a);，就有可能死锁。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较 mutex 对象的地址，始终先加锁地址较小的 mutex可以防止死锁。</p>
<h3 id="对象与指针"><a href="#对象与指针" class="headerlink" title="对象与指针"></a>对象与指针</h3><p>一个动态创建的对象是否活着，光看 指针/引用 是不能看出来的。指针是指向了一块内存，这块内存上的对象如果已经销毁，那么就不能访问，既然不能访问，如何知道对象的状态呢？（万一原址又创建了一个新的对象呢？再万一这个新的对象的类型异于老的对象呢？）换句话说，<strong>判断一个指针是不是合法指针没有高效的办法，这是C/C++ 指针问题的根源。</strong><br>在面向对象程序设计中，对象的关系主要有三种：composition、aggregation、association。composition（组合/复合）关系在多线程里不会遇到什么麻烦，因为对象 x 的生命期由其唯一的拥有者 owner 控制，owner 析构的时候会把 x 也析构掉。后两种关系在 C++ 里比较难办，处理不好就会造成内存泄漏或重复释放。association（关联/联系）是一种很宽泛的关系，它表示一个对象 a 用到了另一个对象 b，调用了后者的成员函数。从代码形式上看，a 持有 b 的指针（或引用），但是 b的生命期不由 a 单独控制。aggregation（聚合）关系从形式上看与 association 相同，除了 a 和 b 有逻辑上的整体与部分关系。如果 b 是动态创建的并在整个程序结束前有可能被释放，那么就会出现竞态。<br></p>
</li>
<li><p>原始指针的问题</p>
<blockquote>
<ul>
<li>指向对象的原始指针(raw pointer)最好不要暴露给别的线程。— 一般用智能指针<br></li>
<li>悬空指针问题。要想安全地销毁对象，最好在别人（线程）都看不到的情况下，偷偷地做。（这正是垃圾回收的原理，所有人都用不到的东西一定是垃圾。）</li>
</ul>
</blockquote>
</li>
</ul>
<p>解决空悬指针的办法是，引入一层间接性+计数器。(handle/body惯用技法，智能指针的思想)中间层的存在让 p1 和 p2 所指的对象永久有效，当计数器为0是释放内存。（shared_ptr+weak_ptr）</p>
<ul>
<li>shared_ptr和rweak_ptr<br><blockquote>
<p>关于shared_ptr我之前在我的github中有简单实现，shared_ptr控制对象的生命期，是强引用，只要有一个指向x对象的shared_ptr存在，该x对象就不会析构，当指向对象x的最后一个shared_ptr析构或reset()调用时，x保证会被销毁。<br><br>weak_ptr是弱智能指针，它不控制对象的生命期，但它知道对象是否还活着，如果对象还活着，weak_ptr可以提升为有效的shared_ptr，如果对象已经死了，提升失败，返回一个空的shared_ptr，提升函数lock()行为是线程安全的。</p>
</blockquote>
</li>
</ul>
<p>shared_ptr/weak_ptr的<strong>计数</strong>在是原子操作，没有用锁，性能不俗。但是sheard_ptr可能会存在循环引用的问题，要避免shared_ptr管理共享资源时引起的循环引用，通常做法是owner持有指向child的shared_ptr，child持有指向owner的weak_ptr.（机智QAQ！）</p>
<h3 id="C-中的内存问题"><a href="#C-中的内存问题" class="headerlink" title="C++中的内存问题"></a>C++中的内存问题</h3><p>这里是作者的写的一个小插曲，简单分析了C++中的常见的内存问题。 （在看到“内存方面的问题在 C++ 里很容易解决，我第一次也是最后一次见到别人的代码里有内存泄漏是在 2004 年实习那会儿，我自己写的 C++ 程序从来没有出现过内存方面的问题。”我除了佩服就只剩佩服了orz）<br><br>简单来说，C++中老生常谈的内存问题/解决 无非是：</p>
<ol>
<li>缓冲区溢出（buffer overrun）：用 std::vector<char>/std::string 或自己编写 Buffer class 来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。（慎重使用strcpy()）</char></li>
<li>悬空指针/野指针：智能指针保平安。</li>
<li>double delete：用 scoped_ptr，只在对象析构的时候释放一次。</li>
<li>memory leak：用 scoped_ptr，对象析构的时候自动释放内存。</li>
<li>申请释放不配对（new[]/delete）：把 new[] 统统替换为 std::vector/scoped_array。</li>
<li>内存碎片（memory fragmentation）</li>
</ol>
</div><div style="padding-bottom: 10px;"><ul class="post-copyright">
<li class="post-copyright-author">
<strong>本文作者：</strong><a href="/about/">ryxiaoer</a><li class="post-copyright-link">
<strong>本文链接：</strong><a href="https://ryxiaoer.github.io/2020/10/17/blog-7.html">https://ryxiaoer.github.io/2020/10/17/blog-7.html</a><li class="post-copyright-license"><strong>版权声明：</strong><a href="/site/">本文所有权归博主所有，转载请注明出处！Thanks</a></div><script type="text/javascript" charset="utf-8" src="https://static.bshare.cn/b/buttonLite.js#uuid=2aceecbb-21d7-4746-a9db-3f8da046a833&amp;style=10&amp;bgcolor=Grey&amp;bp=sinaminiblog,qqim,qzone,weixin&amp;ssc=false"></script><div style="float:right;"><a class="bshareDiv"  href="www.bshare.cn/share">分享按钮</a></div><div class="tags"><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post-nav"><a class="pre" href="/2020/10/19/docker-1.html">docker &lt;学习笔记一&gt;</a><a class="next" href="/2020/10/08/blog-6.html">浅浅浅谈Mysql事务</a></div></div></div></div></div></div><div id="footer-000"><div id="footer-01" style="text-align:center;margin:auto;font-size:14px;background-color:#f5f5f5;"><div class="footer-div-a" style="max-width:1150px;display:flex;margin:0 auto"><div class="footer-div-b" style="padding-left:10px;padding-top:7px;padding-bottom:7px;text-align: left;"><a rel="nofollow">©2020  ❤ </a><a href="/." rel="nofollow" font-size="14px" font-weight="bold">xiaoer's blogs</a></div><div class="footer-div-b" style="padding-right:10px;padding-top:15px;padding-bottom:7px;text-align: right;"><a>&emsp;</a><a href="https://github.com/ryxiaoer/" target="_Blank" title="github" style="font-size:19px;"><i class="fa fa-github" aria-hidden="true"></i></a><a>&emsp;</a><a href="https://blog.csdn.net/weixin_44988779" target="_Blank" title="CSDN"><img class="nofancybox" width="15px" height="15px" src="/img/csdn.ico"/></a></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.1.0" async></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.1.0" async></script><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.1.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.1.0"></script></div></div></html><script type="text/javascript" src="/js/zidingyi.js" async></script>